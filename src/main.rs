extern crate crypto;
#[macro_use]
extern crate diesel; 
extern crate env_logger; 
extern crate failure;
extern crate log;
#[macro_use]
extern crate rouille;
extern crate serde_derive;

use crypto::pbkdf2::{pbkdf2_check,pbkdf2_simple};
use diesel::prelude::*;
use diesel::dsl::{exists, select};
use diesel::r2d2::ConnectionManager;
use failure::{format_err, Error};
use log::debug;
use rouille::{router, Request, Response};
use serde_derive::Serialize; 

type Pool = r2d2::Pool<ConnectionManager<SqliteConnection>>;
mod schema;
mod models;

#[derive(Serialize)]
struct UserId { 
    id: String
}

fn handler(request: &Request, pool: &Pool) -> Result<Response, Error> {
    let response = router!(request, 

        //  Root handler
        (GET) (/) => { 
            Response::text("Authentication Microservices")
        },

        //  To handle singup request, we need a POST method handler fior the /signup path
        //  We declare it in the following way: 
        (POST) (/signup) => { 
            //  This handler is more complex and alsi demonstrates how to parse the parameters of a request
            //  We parse an HTML form with two parameters - email and password
            //  We use post_unput! macro, which expects a request instance and a form declaration with types
            let data = post_input!(request, { 
                email: String,
                password: String,
            })?;

            //  We use the trim method to remove unncessary spacing and the to_lowercase method to convert it to lowercase
            let user_email = data.email.trim().to_lowercase();
            //  We used the password field without any changes and passed it as a parameter to the pbkdf2_simple method of rust crypto
            let user_password = pbkdf2_simple(&data.password, 12345)?;
            
            //  We these information with object relational mapping methods
        
            {
                //  First we check whether the user with theprovided email exists, we use a DSL generated by the diesel crate and if the user doesn't exist, we generate a unique
                
                use self::schema::users::dsl::*;
                let connection_pool = pool.get()?;
                let user_exist: bool = select(exists(
                        users.filter(email.eq(
                            user_email.clone()))))
                                .get_result(&connection_pool)?;
                // if the user doesn't exist, we generate a unique
                // ID for the user using the UUID crate
                if !user_exist { 
                    let uuid = format!("{}", uuid::Uuid::new_v4());
                    //  The handler fills the NewUser instane with corresponding values adn inserts it into a databse
                    let new_user = models::NewUser { 
                        id: &uuid,
                        email: &user_email,
                        password: &user_password,
                    };
                    //  If successful, it returns 
                    diesel::insert_into(schema::users::table)
                        .values(&new_user)
                        .execute(&connection_pool)?;
                    Response::json(&())
                } else { 
                    Response::text(format!("User {} exists", data.email)).with_status_code(400)
                }
            }
        },
        //  /signin request path and parses a query with the data from the HTML form using post_input

        (POST) (/signin) => {
            
            let data = post_input!(request, { 
                email: String,
                password: String,
            })?;
            let user_email = data.email;

            let user_password = data.password; 
            //  After data has been extracted, we get a connection from a pool and use types generated by the diesel crate to send a query to the database
            //  The code gets the first record from the users table with the provided email value 
            {
                use self::schema::users::dsl::*;
                let connection_pool = pool.get()?;

                let user = users.filter(email.eq(user_email))
                    .first::<models::User>(&connection_pool)?;
                
                //  After that we use pbkdf2_check function to check that the password matches stored one

                let valid = pbkdf2_check(&user_password, &user_password)
            
                    .map_err(|err| format_err!("Pass Check Error: {}", err))?;
                //  If the user is valid, we return a JSON value with the user's ID 
                if valid { 
                    let user_id = UserId { 
                        id: user.id,
                    };
                    Response::json(&user_id)
                        .with_status_code(200)
                } else { 
                    Response::text("Access Denied")
                        .with_status_code(403)
                }
            }
        },
        //  For cases
        _ => { 
            Response::empty_404()
        }
    );
    Ok(response)
}



//  The Rouille framework is very simple to use. it contains start_server functions that expect a function to handle 
//  every incoming request. Let's create a main function that uses a diesel crate with an r2d2 pool feature and calls a function to handle request: 

fn main() {
    env_logger::init();

    //  A connection manager for a local test/db SQlite database and a Pool instance with this manager

    let manager = ConnectionManager::<SqliteConnection>::new("test.db");
    let pool = Pool::builder()
        .build(manager)
        .expect("Failed to create connection pool!");
    
    //  We moved pool to the closure and called handler functions, which we delared underneath it to generate a response for a request with Pool as an argument 
    rouille::start_server("127.0.0.1:8001", move |request| { 
        match handler(&request, &pool) {
            Ok(response) => { 
                response
            }
            Err(err) => { 
                Response::text(err.to_string())
                //  Since handler functions have to return a Response instance, we have to return a response with a 500 status code if a handler function returns an error 
                .with_status_code(500)
            }   
        }
    })    
}

